<!doctype html><html lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Make recipes fun again</title><meta content="I hate ads" name=description><link href=./favicon.png rel=icon><style>html{overflow-wrap:break-word;flex-direction:column;height:100%;font-family:sans-serif;display:flex}body{color:#fff;background:#3e3e42;flex-direction:column;margin:0;display:flex;overflow:hidden}body>*{overflow-y:scroll}.content>:not(.full-width),.my-recipes>:not(.full-width){margin-left:.5rem;margin-right:.5rem}a{color:#007acc;font-weight:700;text-decoration:none}.button-like,button{color:#fff;border-width:0;flex-grow:1;padding:.5rem;font-weight:700}a:hover,.button-like:hover,button:hover{cursor:pointer}.button-like,button:disabled{font-weight:400}.flex-row{justify-content:space-between;display:flex}.flex{flex-direction:column;display:flex}.button-like{text-align:center;font-family:sans-serif;font-size:13px}.hidden{display:none}.black{background:#000}.green{background:#338356}.blue{background:#007acc}.purple{background:#d51ced}.pink{background:salmon}.red{background:red}.right{text-align:right}.full-width{width:100%;display:flex}.grow{flex-grow:1}.shrink{flex-grow:0}.no-margin{margin:0}.recipe-row{cursor:pointer;background:#000;align-items:center;gap:5px;margin:.1rem;padding:.5rem;display:flex}.my-recipes-header{padding-bottom:1rem;display:flex}.output{color:#fff;padding-bottom:5rem}.list input:checked+*{opacity:.5;text-decoration:line-through}.list label{gap:10px;padding:.5rem;display:flex;overflow:hidden}.list label:nth-child(2n){background-color:#1a1a1a}.list label:nth-child(odd){background-color:#000}.focus-pane{background-color:#000;flex-direction:column;flex-basis:0;align-items:center;width:100%;display:flex;position:relative;overflow:hidden}.focus-pane-content{box-sizing:border-box;border:5px solid #fff;width:100%;padding:0 .3rem;overflow-y:scroll}.focus-pane .focused-button,.content .close-focused-button{display:none}.resize-handle{cursor:pointer;background:#909090;width:30px;height:10px;position:absolute}.ingredient{color:#add8e6}.amount{color:#00ff7c}.temperature{color:#ff7e7e}.clickable-keyword{white-space:nowrap;cursor:pointer;background:#6c0047;border-radius:1rem;padding:.2rem}label{line-height:2rem}label>div{overflow-x:scroll}label.selected{background:#310f0b!important}.clickable-keyword.selected{background:#006786!important}</style><script>const KEYS = {
	TABS: "tabs"
};

let data = {};
let current_url = null;
let tabs = [];
let show_colors = true;

try {
	tabs = JSON.parse(localStorage.getItem(KEYS.TABS) || '[]');
} catch (e) {
	console.error(e);
}

const save_tabs = () => {
	localStorage.setItem(KEYS.TABS, JSON.stringify(tabs));
}

const find_tab = (url) => {
	for (let tab of tabs) {
		if (tab.url === url) {
			return tab;
		}
	}
	return null;
}

const add_tab = (url, data, save = true) => {
	remove_tab(url, false);
	tabs.push({ url, data });
	if (save) {
		save_tabs();
	}
}

const remove_tab = (url, save = true) => {
	tabs = tabs.filter((e) => e.url !== url);
	if (current_url === url) {
		current_url = "";
	}

	if (save) {
		save_tabs();
	}
}

const remove_markdown = (text) => {
	return text.replaceAll("**", "");
}

const get_last_word = (text, number_of_pieces = 1) => {
	let pieces = text.split(" ");
	while (pieces.length > number_of_pieces) {
		pieces.shift();
	}
	return pieces.join(" ");
}

const AMOUNT_REGEX_RAW = String.raw`
(?:
	// Number and space prefix
	(?:[0-9]+ )?

	// Some number
	[0-9]+

	// number-[other number]
	(?:\s*[\/-]\s*[0-9]+)*

	// number and [other number]
	(?: and [0-9]+)?

	(?:\/[0-9]+)*

	\s*

	(?:\bteaspoon[s]?\b)*

	(?:\bquart[s]?\b)*

	(?:\bstick[s]?\b)*

	(?:\blb[s]?\b)*\s*

	(?:\btsp[s]?\b)*\s*

	(?:\btablespoon[s]?\b)*

	(?:lb[s]\b)*

	(?:\bounce[s]\b)*

	(?:oz[s]?\b)*

	(?:ml[s]?\b)*

	(?:g[s]?\b)*

	(?:cm[s]?\b)*

	(?:cup[s]?\b)*

	(?:day[s]?\b)*

	(?:minute[s]?\b)*

	(?:hour[s]?\b)*

	(?:\")*
)`
	.replaceAll(/^\s+(\/\/.*)?/mg, '')
	.replaceAll("\n", '');
// const AMOUNT_REGEX = String.raw`${AMOUNT_REGEX_RAW}(?: / ${AMOUNT_REGEX_RAW})*`;
const AMOUNT_REGEX = String.raw`${AMOUNT_REGEX_RAW}`;

const extract_keywords_generic = (list, keywords, regexes) => {
	for (let i = 0; i < list.length; i++) {
		let value = list[i];

		for (let r of regexes) {
			let regex = r.regex;
			let kw_type = r.kw_type;

			const match = value.match(regex);
			if (match) {
				for (let some_match of match) {
					let text = some_match.trim();
					if (!text.length || Number(text).toString() === text) {
						continue;
					}
					value = value.replace(text, `**${text}**`);
					text = text.toLowerCase();
					keywords[text] = kw_type;
				}
			}
		}

		list[i] = value;
	}
}

const extract_keywords = (data) => {
	let keywords = {};

	for (let list of [data.ingredients, data.instructions]) {
		extract_keywords_generic(list, keywords, [
			{
				kw_type: "amount",
				regex: new RegExp(String.raw`(${AMOUNT_REGEX})`, "gi"),
			},
			{
				kw_type: "temperature",
				regex: /(\b[0-9]+°\s*[CF]?\b)/gi
			}]);
	}

	for (let i = 0; i < data.ingredients.length; i++) {
		let ingredient = data.ingredients[i];
		if (ingredient.startsWith(LI_PREFIX)) {
			ingredient = ingredient.replace(LI_PREFIX, '');

			// Ingredients
			{
				let regex = /^(?:(?:\*\*[^\*\*]+\*\*)+[\s\(\),]*)+([^,^\(^\*]+)/i;
				const match = ingredient.match(regex);
				if (match) {
					let text = match[match.length - 1].trim();
					ingredient = ingredient.replace(text, `**${text}**`);
					text = text.toLowerCase();
					keywords[text] = "ingredient";

					// Best guess
					let pieces = text.split(" ");
					for (let i = 1; pieces.length - i > 0; i++) {
						let substring = get_last_word(text, pieces.length - i);
						keywords[substring] = "ingredient";
					}
				}
			}
		}
		data.ingredients[i] = ingredient;
	}

	let temp_keywords = Object.keys(keywords);
	temp_keywords.sort((a, b) => b.length - a.length);
	for (let i = 0; i < data.instructions.length; i++) {
		let instruction = data.instructions[i];
		for (let keyword of temp_keywords) {
			instruction = instruction.split(/(\*\*[^\*]+\*\*)/).map((piece) => {
				if (piece.startsWith("**") && piece.endsWith("**")) {
					return piece;
				}
				piece = piece.replaceAll(
					new RegExp(String.raw`\b${keyword}\b`, "gi"), `**${keyword}**`);
				return piece;
			}).join('');
		}

		data.instructions[i] = instruction;
	}

	let regex = /(\b[0-9]+)\b/gi;
	for (let list of [data.ingredients, data.instructions]) {
		for (let i = 0; i < list.length; i++) {
			let item = list[i];
			item = item.split(/(\*\*[^\*]+\*\*)/).map((piece) => {
				if (piece.startsWith("**") && piece.endsWith("**")) {
					return piece;
				}
				let matches = piece.match(regex);
				if (matches) {
					piece = piece.replaceAll(regex, "**$1**");
					for (let match of matches) {
						keywords[match] = "amount";
					}
				}
				return piece;
			}).join('');
			list[i] = item;
		}
	}

	return keywords;
}


const generate_id_for_keyword = (keywords, term) => {
	term = term.toLowerCase();
	let last_word = get_last_word(term);
	if (keywords[last_word]) {
		return last_word;
	}
	return term.replaceAll(/\s/g, '_');
}

let ID = 0;
const generate_unique_id = (prefix) => {
	return `${prefix}_${++ID}`;
}

let SELECTED_KEYWORD = null;
const click_keyword = (e) => {
	e.preventDefault();
	for (let element of document.querySelectorAll(`.selected`)) {
		element.classList.remove("selected");
	}

	if (e.target.id === SELECTED_KEYWORD) {
		SELECTED_KEYWORD = null;
	} else {
		SELECTED_KEYWORD = e.target.id;
		for (let element of document.querySelectorAll(`#${e.target.id}`)) {
			element.classList.add("selected");
			while (element) {
				if (element.tagName == "LABEL") {
					element.classList.add("selected");
					break;
				}
				element = element.parentElement;
			}
		}
	}
}

const checkbox_on_change = (e) => {
	for (let element of document.querySelectorAll(`#${e.target.id}`)) {
		if (element != e.target) {
			element.checked = e.target.checked;
		}
	}
};

let State = {
	None: 0,
	Ingredients: 1,
	Instructions: 2,
	Notes: 3,
};

const SUB_HEADER_PREFIX = "### ";
const SUB_SUB_HEADER_PREFIX = "#### ";
const LI_PREFIX = "   - ";

let get_title = (doc) => {
	for (let meta of doc.querySelectorAll("meta")) {
		let property = meta.getAttribute("property");
		if (property === "og:title") {
			return meta.getAttribute("content") || "";
		}
	}
	return "";
}

const split_text = (value, keywords) => {
	if (!show_colors) {
		return [
			{
				tag: "span",
				text: value,
			}
		];
	}
	let elements = [];

	for (let text of value.split(/(\*\*[^\*]+\*\*)/)) {
		if (text.startsWith("**") && text.endsWith("**")) {
			text = text.replace(/^\*\*/, '').replace(/\*\*$/, '');
			let some_class = keywords[text.toLowerCase()] || 'unknown';
			let classes = [some_class];
			let onclick = null;
			if (some_class == "ingredient") {
				classes.push("clickable-keyword");
				onclick = click_keyword;
			}

			elements.push({
				tag: "b",
				text,
				classes,
				onclick,
				attributes: {
					id: generate_id_for_keyword(keywords, text.toLowerCase()),
				}
			});
		} else {
			elements.push({
				tag: "span",
				text
			});
		}
	}
	return elements;
}

const extract_text = (element) => {
	if (element.nodeName.startsWith("H")) {
		let should_repeat = true;
		while (should_repeat) {
			should_repeat = false;
			for (let child of element.children) {
				if (child.nodeName == "DIV") {
					element.removeChild(child);
					should_repeat = true;
				}
			}
		}
	}

	return element.textContent.replace(/▢/, "")
		.replaceAll(/(\.)([A-Z])/g, '$1 $2')
		.replace(/^(?:Step\s*)?[0-9]+\.\s+/, '')
		.replaceAll(" , ", ', ')
		.replaceAll("–", '-')
		.replaceAll("”", '"')
		.replaceAll("½", '1/2')
		.replaceAll("¾", '3/4')
		.replaceAll("⅓", '1/3')
		.replaceAll("⅔", '2/3')
		.replaceAll("¼", '1/4')
		.replaceAll(/([0-9]+)\s+-\s+([0-9]+)/g, '$1-$2')
		.trim();
}

let extract_data = (text, title) => {
	let parser = new DOMParser();
	let doc = parser.parseFromString(text, "text/html");
	let state = State.None;
	let level = null;
	let ingredients = [];
	let instructions = [];
	let notes = [];
	title = title || get_title(doc);
	let elements = [...doc.querySelectorAll("li,p,h1,h2,h3,h4,h5,h6")];
	let firstIndex = Math.max(0, elements.map((e) => extract_text(e)).findLastIndex((e) => e.toLowerCase() === "ingredients"));

	for (let i = firstIndex; i < elements.length; i++) {
		let element = elements[i];

		// Remove any junk from a header
		if (element.nodeName.startsWith("H")) {
			if (element.nodeName == level) {
				state = State.None;
			}
		}

		let text = extract_text(element);
		if (!text.length) {
			continue;
		}

		let temp = text.toLowerCase();
		switch (temp) {
			case "ingredients":
				state = State.Ingredients;
				level = element.nodeName;
				continue;
			case "instructions":
				state = State.Instructions;
				level = element.nodeName;
				continue;
			case "notes":
				state = State.Notes;
				level = element.nodeName;
				continue;
			default:
				break;
		}

		switch (element.nodeName) {
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "H7":
			case "H8":
			case "H9":
				text = text.replace(/:$/, '');
				text = `${SUB_HEADER_PREFIX}${text}`;
				break;
			default:
				text = `${LI_PREFIX}${text}`;
				break;
		}

		switch (state) {
			case State.Ingredients:
				ingredients.push(text);
				break;
			case State.Instructions:
				if (text.startsWith(LI_PREFIX)) {
					let matches = text.replace(LI_PREFIX, '').match(/^([^\.\:]+):(.+)/);
					if (matches) {
						instructions.push(`${SUB_SUB_HEADER_PREFIX}${matches[1]}`);
						instructions.push(`${LI_PREFIX}${matches[2]}`);
					} else {
						instructions.push(text);
					}
				}
				break;
			case State.Notes:
				notes.push(text);
				break;
			default:
				break;
		}
	}

	return {
		title,
		ingredients,
		instructions,
		notes,
	};
};

const get_markdown_list = (list, keywords, title) => {
	let rv = "";
	if (list.length) {
		rv += `\n\n## ${title}\n`;
		for (let item of list) {
			if (item.startsWith(SUB_HEADER_PREFIX) || item.startsWith(SUB_SUB_HEADER_PREFIX)) {
				item = `\n\n${item}\n`;
			} else {
				rv += `\n${item}`;
			}
		}
	}
	return rv;
};

const data_to_markdown_string = (data) => {
	let markdown = "";

	if (data.title) {
		markdown += `# ${data.title}\n`;
	}

	markdown += get_markdown_list(
		data.ingredients,
		data.keywords,
		"Ingredients"
	);
	markdown += get_markdown_list(
		data.instructions,
		data.keywords,
		"Instructions"
	);
	markdown += get_markdown_list(data.notes, data.keywords, "Notes");

	return markdown.trim();
};

window.onload = () => {
	const contentDiv = document.querySelector(".content");
	const myRecipesDiv = document.querySelector(".my-recipes");
	const outputDiv = document.querySelector(".output");

	const copyFromClipboardButton = document.querySelector(
		"#copy-from-clipboard-button"
	);
	const copyMarkdownToClipboardButton = document.querySelector(
		"#copy-markdown-to-clipboard-button"
	);

	const show_my_recipes = () => {
		clear_div(myRecipesDiv);

		myRecipesDiv.removeAttribute("hidden");
		contentDiv.setAttribute("hidden", true);
		if (focused_pane_element) {
			focused_pane_element.classList.add("hidden");
		}

		{
			let parent = add_child({ tag: "div", classes: ["my-recipes-header"] }, myRecipesDiv);
			add_child({ tag: "h2", text: "My Saved Recipes", classes: ["grow", "no-margin"] }, parent);
			let back_button = add_child({ tag: "button", text: "Back", classes: ["red", "shrink"] }, parent);
			back_button.addEventListener("click", () => {
				show_current_recipe();
			});
		}

		for (let i = tabs.length - 1; i >= 0 && tabs.length; i--) {
			let tab = tabs[i];
			let parent = add_child({ tag: "div", classes: ["recipe-row"] }, myRecipesDiv);
			parent.addEventListener("click", (event) => {
				event.stopPropagation();
				doit(tab.url);
			});

			add_child({ tag: "span", text: tab.data.title || "<missing title>", classes: ["grow"] }, parent);
			let delete_button = add_child({ tag: "button", text: "Delete", classes: ["red", "shrink"] }, parent);
			delete_button.addEventListener("click", (event) => {
				event.stopPropagation();
				remove_tab(tab.url);
				show_my_recipes();
			});
		}
	};

	const show_current_recipe = () => {
		myRecipesDiv.setAttribute("hidden", true);
		contentDiv.removeAttribute("hidden");
		if (focused_pane_element) {
			focused_pane_element.classList.remove("hidden");
		}
	}

	const add_child = (data, parent = outputDiv) => {
		if (data instanceof Array) {
			for (let child of data) {
				add_child(child, parent);
			}
			return null;
		} else {
			if (!data.tag) {
				if (data.text) {
					parent.append(data.text);
				}
				return null;
			}


			let child = document.createElement(data.tag);
			if (data.text) {
				child.textContent = data.text;
			}

			if (parent) {
				if (data.prepend) {
					parent.prepend(child);
				} else {
					parent.appendChild(child);
				}
			}

			if (data.attributes) {
				for (let key of Object.keys(data.attributes)) {
					child.setAttribute(key, data.attributes[key]);
				}
			}
			if (data.classes) {
				for (let some_class of data.classes) {
					child.classList.add(some_class);
				}
			}
			if (data.style) {
				for (let style of Object.keys(data.style)) {
					child.style[style] = data.style[style];
				}
			}
			if (data.children) {
				add_child(data.children, child);
			}
			if (data.onclick) {
				child.addEventListener("click", data.onclick);
			}
			if (data.onchange) {
				child.addEventListener("change", data.onchange);
			}
			if (data.onmousedown) {
				child.addEventListener("mousedown", data.onmousedown);
				child.addEventListener("touchstart", data.onmousedown);
			}
			if (data.ondrag) {
				child.addEventListener("drag", data.ondrag);
			}
			if (data.ondragstart) {
				child.addEventListener("dragstart", data.ondragstart);
			}
			if (data.ondragend) {
				child.addEventListener("dragend", data.ondragend);
			}

			return child;
		}
	};

	const clear_div = (div = outputDiv) => {
		div.innerHTML = "";
	}

	const show = (element) => {
		element.removeAttribute("hidden");
	}

	const hide = (element) => {
		element.setAttribute("hidden", "");
	}

	let focused_pane_element = null;
	const remove_focused_panes = () => {
		for (let element of document.querySelectorAll(".focus-pane")) {
			element.parentElement.removeChild(element);
		}
	}

	const focus = (elements) => {
		remove_focused_panes();

		let shared_data = { did_drag: false, total_height: 0 };

		let pane = add_child({
			tag: "div",
			style: {
				"min-height": `30vh`,
			},
			classes: ["focus-pane"],
		}, document.body);

		let content = add_child({
			tag: "div",
			classes: ["focus-pane-content"],
			prepend: true,
		}, pane);

		for (let element of elements) {
			content.appendChild(element.cloneNode(true));
		}

		add_child({
			tag: "div",
			classes: ["resize-handle"],
			onmousedown: (e) => {
				e.preventDefault();

				let mousemove = (e) => {
					e.preventDefault();
					let height = document.body.clientHeight - (e.pageY || e.touches[0].pageY);
					pane.style.minHeight = `max(20px, min(${height}px, ${shared_data.total_height}px))`;
				};

				let mouseup = (e) => {
					e.preventDefault();
					shared_data.did_drag = true;
					document.removeEventListener("mousemove", mousemove);
					document.removeEventListener("touchmove", mousemove);
					document.removeEventListener("mouseup", mouseup);
					setTimeout(() => {
						shared_data.did_drag = false;
					}, 0);
				};

				document.addEventListener("mousemove", mousemove);
				document.addEventListener("touchmove", mousemove);
				document.addEventListener("mouseup", mouseup);
			},
		}, pane);

		for (let button of pane.querySelectorAll(".close-focused-button")) {
			button.addEventListener("click", remove_focused_panes);
		}

		shared_data.total_height = content.scrollHeight + 10;
		pane.style.minHeight = `min(30vh, ${shared_data.total_height}px)`;

		for (let input of content.querySelectorAll("input")) {
			input.addEventListener("change", checkbox_on_change);
		}

		for (let keywordEl of content.querySelectorAll(".clickable-keyword")) {
			keywordEl.addEventListener("click", click_keyword);
		}

		focused_pane_element = pane;
	}

	const render_data = (data, url) => {
		data = structuredClone(data);
		let keywords = {};
		if (show_colors) {
			keywords = extract_keywords(data);
		}

		// Clear the old data out
		clear_div();
		remove_focused_panes();

		if (data.title) {
			add_child({ tag: "h1", text: data.title });
		}

		if (url) {
			add_child({
				tag: "div",
				classes: ["flex-row"],
				children: [
					{
						tag: "a",
						text: "Toggle colors",
						onclick: () => {
							show_colors = !show_colors;
							doit(current_url);
						}
					},
					{
						tag: "a",
						text: "Open the original",
						attributes: {
							target: "_blank",
							href: url
						}
					}
				]
			});
		}

		render_list(data.ingredients, keywords, "Ingredients");
		render_list(data.instructions, keywords, "Instructions");
		render_list(data.notes, keywords, "Notes");

		for (let header of contentDiv.querySelectorAll("h1,h2,h3,h4")) {
			let list = header.nextSibling;
			if (list && list.hasChildNodes() && list.classList.contains("list")) {
				add_child({
					tag: "a",
					text: " +",
					classes: ["focused-button"],
					onclick: () => {
						focus([header, list]);
					},
				}, header);

				add_child({
					tag: "a",
					text: " close",
					classes: ["close-focused-button"],
				}, header);
			}
		}
	};

	const render_list = (list, keywords, title) => {
		if (list.length) {
			add_child({ tag: "h2", text: title });
			let parent = add_child({ tag: "div", classes: ["list"] });
			for (let item of list) {
				if (item.startsWith(LI_PREFIX)) {
					item = item.substr(LI_PREFIX.length);
				} else if (item.startsWith(SUB_HEADER_PREFIX)) {
					item = item.substr(SUB_HEADER_PREFIX.length);
					add_child({ tag: "h3", text: remove_markdown(item) });
					parent = add_child({ tag: "div", classes: ["list"] });
					continue;
				} else if (item.startsWith(SUB_SUB_HEADER_PREFIX)) {
					item = item.substr(SUB_SUB_HEADER_PREFIX.length);
					add_child({ tag: "h4", text: remove_markdown(item) });
					parent = add_child({ tag: "div", classes: ["list"] });
					continue;
				}

				// Simple li
				// add_child({ tag: "li", text: item }, parent);

				// More complex checkbox
				add_child({
					tag: "label",
					children: [{
						tag: "input",
						onchange: checkbox_on_change,
						attributes: {
							id: generate_unique_id("checkbox"),
							type: "checkbox",
						}
					}, {
						tag: "div",
						children: split_text(item, keywords)
					}
					]
				}, parent);
			}
		}
	};

	const set_data = (url, new_data) => {
		current_url = url;
		data = new_data;
		copyMarkdownToClipboardButton.removeAttribute("disabled");
		render_data(data, url);
	}

	const valid_url = (url) => {
		if (!url || !url.length || url.length > 500) {
			return false;
		}

		try {
			url = new URL(url);
		} catch (_) {
			return false;
		}

		return url.protocol === "http:" || url.protocol === "https:";
	}

	const show_help = () => {
		clear_div();
		add_child([
			{
				tag: "p",
				text: "Welcome to recipe scraper!"
			},
			{
				tag: "p",
				text: "New here? ",
				children: [
					{
						tag: "a",
						text: "Here",
						attributes: {
							href: "https://github.com/loremdipso/recipe-scraper?tab=readme-ov-file#recipe-scraper",
							target: "_blank"
						}
					},
					{
						tag: "span",
						text: " are some instructions to get you started."
					}
				]
			}
		]);
	}

	const doit = (url, title, force_refresh) => {
		// unlikely we're going to run out of numbers, but still...
		ID = 0;
		SELECTED_KEYWORD = null;
		show_current_recipe();

		if (!force_refresh) {
			let tab = find_tab(url);
			if (tab) {
				set_data(tab.url, tab.data);
				return;
			}
		}

		if (!valid_url(url)) {
			show_help();
			return;
		}

		fetch(`https://corsproxy.io/?url=${encodeURI(url)}`).then((result) => {
			if (result.status !== 200) {
				clear_div();
				add_child({ tag: "h1", text: `Uh-oh, got an error code while trying to fetch that recipe. Sorry :/ Some sites don't work with this app, unfortunately` });
			} else {
				result.text().then((text) => {
					let data = extract_data(text, title);
					add_tab(url, data);
					set_data(url, data);
				});
			}
		});
	};

	copyFromClipboardButton.addEventListener("click", async () => {
		const items = await navigator.clipboard.read();
		for (const item of items) {
			for (const type of item.types) {
				const blob = await item.getType(type);
				const text = await blob.text();
				doit(text);
				return;
			}
		}
	});

	copyMarkdownToClipboardButton.addEventListener("click", async () => {
		let markdown = data_to_markdown_string(data);
		await navigator.clipboard.writeText(markdown);
	});

	let url = new URL(document.location);
	const sharedLink =
		url.searchParams.get("link") ||
		url.searchParams.get("description") ||
		url.searchParams.get("url");
	if (sharedLink) {
		doit(decodeURI(sharedLink), decodeURIComponent(url.searchParams.get("name") || ''));
	} else {
		show_help();
	}

	let installPrompt = null;
	const installButton = document.querySelector("#install-button");
	window.addEventListener("beforeinstallprompt", (event) => {
		event.preventDefault();
		installPrompt = event;
		show(installButton);
	});

	installButton.addEventListener("click", async () => {
		if (!installPrompt) {
			return;
		}
		await installPrompt.prompt();
		installPrompt = null;
		hide(installButton);
	});

	const reloadButton = document.querySelector("#reload-button");
	reloadButton.addEventListener("click", async () => {
		if (current_url) {
			doit(current_url, '', true);
		}
	});

	const myRecipesButton = document.querySelector("#my-recipes-button");
	myRecipesButton.addEventListener("click", async () => {
		show_my_recipes();
	});
};


function make_resizable(element, handle) {
}</script><link href=manifest.json rel=manifest></head><body><a aria-label="View source on GitHub" href=https://github.com/loremdipso/recipe-scraper style=z-index:1000;position:fixed;bottom:-.5rem;right:0 target=_blank> <svg viewbox="0 0 250 250" aria-hidden=true height=40 style=fill:#151513;color:#fff;border:0;transform:scaleY(-1) width=40><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" style="transform-origin:130px 106px" class=octo-arm fill=currentColor></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" class=octo-body fill=currentColor></path></svg></a><style>.github-corner:hover .octo-arm{animation:.56s ease-in-out octocat-wave}@keyframes octocat-wave{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (width<=500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:.56s ease-in-out octocat-wave}}</style><div class=content><div class="input full-width"><button class=green id=copy-from-clipboard-button>Copy from clipboard</button><button class=blue disabled id=copy-markdown-to-clipboard-button>Get markdown</button><button class=black id=reload-button>Reload</button><button class=pink id=my-recipes-button>My recipes</button><button class=purple hidden id=install-button>Install</button></div><div class=output></div></div><div class=my-recipes></div></body></html>